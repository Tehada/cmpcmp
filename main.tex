\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian, english]{babel}
\usepackage{listings} % исходный код
\usepackage{color}

\lstset{ % General setup for the package
    language=C++,
    basicstyle=\small\sffamily,
    numbers=left,
    numberstyle=\tiny,
    frame=tb,
    tabsize=4,
    columns=fixed,
    showstringspaces=false,
    showtabs=false,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue}
}
\title{Решения задач по книге Дасгупта}
\author{Александр Шарипов}
\date{\today}

\begin{document}

\pagenumbering{gobble}
\maketitle
\newpage
\pagenumbering{arabic}

первое определение нп задачи -- проверяется доказательство за полиномиальное время
второе -- с использование МТ

определение класса П

определение класса нпс

8 глава

\subparagraph{8.1} \textit{Покажите, что если поисковую задачу коммивояжёра можно решить за полиномиальное время, то и оптимизационный вариант можно решить за полиномиальное время.}

Пусть \textbf{n} -- кол-во вершин в графе, \textbf{A} -- матрица расстояний размера \textbf{[n x n]}. Считаем, что поисковую задачу мы умеем решать эффективно (за полиномиальное время). Сначала проверим, есть ли хоть один гамильтонов цикл для матрицы \textbf{A}, для этого найдём максимальный элемент \textbf{m} в матрице \textbf{A}, это займёт полиномиальное время -- \textbf{O(n^2)} и проверим, существует ли цикл веса не более \textbf{n * m}, проходящий по всем вершинам графа -- полиномиальное время по условию. Если не существует, то задача решена, если существует, то организуем бинарный поиск на отрезке \textbf{[n; n * m]} -- \textbf{log(n(m - 1))}.

\subparagraph{8.4} определение задачи о вершинном покрытии -- покрытие вершинами всех рёбер в графе.

a
Воспользуемся первым определением класса задач нп. Пусть нам предъявили набор вершин, которые предположительно образуют клику, тогда мы умеем за полиномиальное время проверять, так ли это.

b
В приведённом доказательстве построено сведение к нп полной задаче, а по определению класса нпс сведение нужно строить в обратную сторону, от нпс к нашей задаче.

c
Неверно утверждение: "Ясно, что множество вершин C ⊆ V является вершинным покрытием в G тогда и только тогда, когда его дополнение V − C является кликой в G." Дополнением вершинного покрытия будет независимое мн-во.

d
В задаче 3-clique клика может состоять только из 3 или 4 вершин. Рассмотрим все четвёрки вершин, их C_n^4 == O(V^4), для каждой четвёрки выполним константную проверку, образует ли она клику. Аналогично рассмотрим всевозможные тройки вершин, и проверим на наличие клики, это займёт O(V^3) времени. Значит суммарная сложность алгоритма будет O(V^4) + O(V^3) = O(V^4).

\subparagraph{8.5}

Трёхдольное сочетание -> выполнимость

Сопоставим треугольники переменным, а вершины дизъюнктам. Для каждого треугольника i создадим переменную x_i, для каждой вершины k из 3dm задачи создадим дизъюнкт d_k, содержащий переменные, треугольники которых, содержат эту вершину k. Тогда для каждой вершины k из 3dm задачи мн-во треугольников, содержащих её, будет соответствовать мн-ву переменных, содержащихся в дизъюнкте d_k. Тогда условие "вершина входит в треугольник" в новой задаче будет выглядеть так: "дизъюнкт принимает значение 1", но в нашем построении ещё нет условия на то, что вершина входит ровно в один треугольник. В терминах задачи выполнимости это будет означать, что в каждом дизъюнкте ровно одна переменная должна принимать значение 1. Это кодируется с помощью дополнительных дизъюнктов, описывающих всевозможные ситуации, присутствия более одной переменной со значением 1.

Гамильтонов путь -> выполнимость





\subparagraph{8.8}

\subparagraph{8.9}

\subparagraph{8.12}

\subparagraph{8.13}

\subparagraph{8.16}

\subparagraph{8.17}

\subparagraph{8.20}

\subparagraph{8.21}

9 глава

\subparagraph{9.4}

\subparagraph{9.6}

\subparagraph{9.7}

\subparagraph{9.8}

\subparagraph{9.9}

\end{document}
