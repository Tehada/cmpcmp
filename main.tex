\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian, english]{babel}
\usepackage{listings} % исходный код
\usepackage{color}

\lstset{ % General setup for the package
    language=C++,
    basicstyle=\small\sffamily,
    numbers=left,
    numberstyle=\tiny,
    frame=tb,
    tabsize=4,
    columns=fixed,
    showstringspaces=false,
    showtabs=false,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue}
}
\title{Решения задач по книге Дасгупта}
\author{Александр Шарипов}
\date{\today}

\begin{document}

\pagenumbering{gobble}
\maketitle
\newpage
\pagenumbering{arabic}

Определения:
--распределить их по тексту

\textbf{P} -- класс задач, для которых существуют алгоритмы, с полиномиальным временем работы.
\textbf{NP} -- класс задач, для которых проверка решения осуществляется за полиномиальное время. \textbf{(1)}
\textbf{NP} -- класс задач, для которые решаются за полиномиальное время на НМТ. \textbf{(2)}
\textbf{NPC} -- класс задач из \textbf{NP}, к которым можно свести любую задачу из \textbf{NP}.

DONE: 8.1, 8.4, 8.5, 8.8, 8.9, 8.12, 9.4

8 глава:

\subparagraph{8.1}

\textit{Пусть \textbf{n} -- кол-во вершин в графе, \textbf{A} -- матрица расстояний размера \textbf{[n x n]}, поисковую задачу мы умеем решать эффективно (за полиномиальное время).}

Покажем, что, умея эффективно решать поисковую задачу коммивояжёра, мы сможем построить эффективный алгоритм для решения оптимизационной задачи. На первом этапе убедимся, что в графе есть хоть один гамильтонов цикл: найдём в матрице \textbf{A} максимальный элемент \textbf{m}, это займёт полиномиальное время, т.к. в матрице \textbf{O(n^2)} элементов. Затем проверим, существует ли гамильтонов цикл веса не более \textbf{n * m}, это займёт полиномиальное время по условию. Пусть гамильтонов цикл существует, тогда вторым этапом будет бинарный поиск длины минимального цика на отрезке \textbf{[n; n * m]}. За \textbf{O(log(n(m - 1)))} операций минимальная длина гамильтонова цикла будет найдена. Поскольку длина входа ограничена оценкой O(exp(n)), бинарный поиск будет эффективен.

Общая сложность алгоритма: O(n^2) + [полиномиальное время] + O(log(n(m - 1))).
---------------------------------------------------------------------------------------------выделить цветом нужные места!

\subparagraph{8.4}

\textit{в задаче о вершинном покрытии нужно найти покрытие вершинами всех рёбер в графе.}

a

Воспользуемся определением \textbf{(1)} класса задач \textbf{NP}. Пусть нам предъявили набор вершин, которые предположительно образуют клику. Тогда алгоритм верификации будет перебирать каждую вершину из предложенного множества и проверять, смежна ли она со всеми остальными из этого множества. Такая проверка займёт \textbf{O(n * (n - 1))}, где \textbf{n} -- размер клики. Значит проверка осуществляется за полиномиальное время => принадлежит \textbf{NP}.
----------------------------------------------------------добавить значок выше

b

Сведение построено не в ту сторону. Для доказательства того, что задача принадлежит \textbf{NPC} обычно к ней сводят какую-нибудь задачу из \textbf{NPC} или показывают, что любая задача из \textbf{NP} сводится к ней.

c

\textit{Здесь условие о клике заменено на условие о независимом множестве. Изменяется утверждение: "Ясно, что множество вершин C ⊆ V является вершинным покрытием в G тогда и только тогда, когда его дополнение V − C является --кликой-- независимым множеством в G."}

Если сравнить исправленное сведение со сведением задачи о независимом множестве к ВП на странице 249, то можно убедиться, что здесь по сути переписали уже имеющееся сведение, только в обратную сторону. Обозначим утверждения: \textbf{A} = "НМ принадлежит \textbf{NPC}", \textbf{B} = "ВП принадлежит \textbf{NPC}" Тогда на с. 249 утв. \textbf{A} уже было доказано, и из него мы выводили \textbf{B}. А здесь мы пытаемся доказать, \textbf{A} в предположении, что \textbf{B} верно, хотя \textbf{B} мы умеем выодить только из \textbf{A}. Такое доказательство некорректно.

d

В задаче 3-clique клика может состоять только из 3 или 4 вершин. Рассмотрим все четвёрки вершин, их C_n^4 == O(V^4), для каждой четвёрки выполним константную проверку (в пункте a описан алгоритм проверки), образует ли она клику. Аналогично рассмотрим всевозможные тройки вершин, и проверим на наличие клики, это займёт O(V^3) времени.

Общая сложность алгоритма: O(V^4) + O(V^3).
--длбавить ссылочку

Определение: \textit{означивание} переменных \textbf{x_1, x_2, ..., x_n} -- это набор из нулей и единиц длины \textbf{n}.

Лемма_1: пусть есть множество булевых переменных \textbf{A = {x_1, x_2, ..., x_n}}, множество означиваний для этих переменных \textbf{B}. Тогда можно построить формулу, в которой каждый дизъюнкт содержит ровно один раз каждую переменную из \textbf{A} или её отрицание, и только означивания из множества \textbf{B} обращают формулу в 1. Т.е. мы можем заставить переменные принимать только те значения, которые нам нужно.

Док-во: рассмотрим множество \textbf{K} всевозможных дизъюнктов, каждый из которых содержит ровно одну переменную из \textbf{A} или её отрицание. Для каждого означивания из \textbf{B} удалим из \textbf{K} дизъюнкт, который обращается в 0 на этом означивании. Из оставшихся дизъюнктов в \textbf{K} составим формулу \textbf{f}. По построению эта формула будет допускать только означивания из множества \textbf{B}.

\subparagraph{8.5}

\textit{Трёхдольное сочетание -> выполнимость}

\textit{3dm == 3d matching == трёхдольное сочетание}

Сопоставим треугольники переменным, а вершины дизъюнктам. Для каждого треугольника \textbf{i} создадим переменную \textbf{x_i}, для каждой вершины \textbf{k} из \textbf{3dm} задачи создадим дизъюнкт \textbf{d_k}. Пусть вершина \textbf{k} соединена с треугольниками, образующими множество \textbf{T}, тогда \textbf{d_k} содержит переменные, соответствующие треугольникам из множества \textbf{T}. Тогда условие "вершина \textbf{k} входит в треугольник при разбиении на тройки" в новой задаче будет выглядеть так: "дизъюнкт \textbf{d_k} принимает значение 1 при означивании переменных". Но в нашем построении ещё нет условия на то, что вершина входит ровно в один треугольник. В терминах задачи выполнимости это будет означать, что в каждом дизъюнкте ровно одна переменная должна принимать значение 1. По лемме_1 мы можем построить формулу \textbf{f}, которая будет кодировать нужные нам означиания. Тогда допишем \textbf{f} в конце нашей формулы.

\textit{Гамильтонов путь -> выполнимость}

Рассмотрим набор дизъюнктов: \textbf{(x_11 ˇ x_21 ˇ ... ˇ x_n1), (x_12 ˇ x_22 ˇ ... ˇ x_n2), ..., (x_1n ˇ x_2n ˇ ... ˇ x_nn)}, \textbf{i}-й дизъюнкт соответствует \textbf{i}-ому месту в гамильтоновом цикле. Если дизъюнкт принимает значение 1, то на \textbf{i}-ом месте есть вершина. Выполнение формулы, составленной из этих дизъюнктов означает, что существует гамильтонов цикл. Но не совсем. В каждом дизъюнкте ровно одна переменная должна принимать значение 1, это означает, что вершина с соотв. номером стоит на \textbf{i}-ом месте в цикле. Воспользуемся леммой_1, чтобы получить формулу \textbf{f}

--посмотреть дизъюнкты

\subparagraph{8.8}

\textit{3SAT -> exact 4SAT}

Сначала проверим, что ни один дизъюнкт не содержит переменную и её отрицание. Затем из каждого дизъюнкта выбросим повторяющиеся переменные. Пусть \textbf{A} -- множество новых переменных, которые будут дополнять каждый дизъюнкт до размера 4. На данном этапе у нас есть формула, в которой длина каждого дизъюнкта равна 4 и все переменные в каждом дизъюнкте разные. Осталось добавить дизъюнкты, которые будут задавать значение 0 всем переменным множества \textbf{A}. Для этого дополним \textbf{A} новыми переменными так, чтобы размер A был кратного четырём, а затем разобьём переменные из \textbf{A} на четвёрки. Для каждой четвёрки создаётся создаётся множество дизъюнктов, которые будут задавать значения 0 этим переменным. Каждое такое множество содержит дизъюнкты со всевозможными комбинациями отрицаний переменных, кроме дизъюнкта, в котором нет отрицаний. Затем дизъюнкты из этих множеств сваливаются в нашу формулу.

---добавить палки и ссылки

\subparagraph{8.9}

Докажем, что \textbf{hitting set принадлежит NP}. Пусть нам дали множество \textbf{H}, которое предположительно покрывает все множества \textbf{S_1, S_2, ..., S_n}, тогда мы для каждого элемента из \textbf{H} проверяем, из какого он множества, и отмечаем соответствующее множество. Также нужно проверить, что \textbf{|H| ≤ b}. Ясно, что все эти проверки займут полиномиальное время. Теперь сведём задачу ВП к нашей. Для каждого ребра \textbf{(u, v)} из графа задачи ВП создаём множество, содержащее вершины \textbf{u} и \textbf{v}. Ясно, что построение множеств занимает \textbf{O(E)} времени, где \textbf{E} -- количество рёбер в графе.

\subparagraph{8.12}

\textit{KST -- k-spanning tree}

a

Покажем, что задача \textbf{KST} принадлежит \textbf{NP}. Можно эффективно проверить, что данное множество вершин совпадает с множеством вершин графа, рёбра образуют дерево и степень каждой вершины не превосходит \textbf{k}.

b

Докажем, что \textbf{KST} принадлежит \textbf{NPC}. Для этого сведём задачу о гамильтоновом пути к нашей задаче. Заметим, что для любого экземпляра задачи о гамильтоновом пути мы можем рассмотреть задачу \textbf{KST} на этом же графе при k == 2. Частный случай задачи \textbf{KST} принадлежит \textbf{NPC} => \textbf{KST} принадлежит \textbf{NPC}.

\subparagraph{8.13}

\subparagraph{8.16}

\subparagraph{8.17}

\subparagraph{8.20}

\subparagraph{8.21}

9 глава:

\subparagraph{9.4}

\textit{Пусть \textbf{n} -- количество вершин в графе, \textbf{m} -- размер максимального независимого множества, \textbf{K} -- независимое множество которое находится эффективным алгоритмом}

Вместо того, чтобы доказывать оценку \textbf{|K| ≥ m / (d + 1)}, докажем более сильную: \textbf{|K| ≥ n / (d + 1)}. Ясно, что тогда будет выполнено \textbf{|K| ≥ m / (d + 1)}. Рассмотрим произвольную вершину \textbf{v}, добавим её в \textbf{K}, затем удалим \textbf{v} и все смежные с ней из графа. Было удалено не более \textbf{d + 1} вершины, при этом размер независимого множества увеличился на 1. Будем повторять эту операцию, пока в графе есть вершины. Получаем оценку \textbf{|K| ≥ n / (d + 1)}.

\subparagraph{9.6}

\subparagraph{9.7}

\subparagraph{9.8}

\subparagraph{9.9}

\end{document}
